#ifndef NEWCELL_H
#define NEWCELL_H

#include <QObject>
#include <QRect>
#include <QPainter>
#include <QPointF>
#include "mymethod.h"
#include "newpan.h"

class NewPan;
class NewCell : public QObject
{
    Q_OBJECT
public:
    explicit NewCell(int nID, bool bStatus, double dCenterX, double dCenterY);
    virtual ~NewCell();
public:
    NewPan*          m_pNewPan;
    QPainter*        m_pPainter;          //在此绘制
    QRect            m_rRect;             //单元所在的正方形
    int              m_nCenWave[WAVE_NUM];//中心轴运行的波形数据
    int              m_nEccWave[WAVE_NUM];//偏心轴运行的波形数据
private:
    const double m_dCen = 14.5;    //中心轴长度
    const double m_dEcc = 30.5;    //偏心轴长度
    double m_dREcc;                //偏心轴外倒角圆弧半径

    QPointF m_ptEccR1;             //偏心轴前端半圆中心点
    QPointF m_ptEccR2;             //偏心轴展开时旋转中心点
    
    QPainterPath m_path;           //偏心轴外形轨迹
    QPainterPath m_pathArc;        //运行的圆弧轨迹

private:
    int          m_nID;                 //单元编号
    bool         m_bStatus;             //单元是否运行的，0否，1是
    double       m_dCenterX;            //单元中心X
    double       m_dCenterY;            //单元中心Y
    double       m_dRadius;             //单元运行半径
    double       m_dRunRadian;          //单元运行到指定点时的弧度rad,从单元圆心相对于x轴正方向
    int          m_nRunRadSlice;        //单元运行到指定点时的弧度片，rad*100,方便计算,相对于x轴正方向
    double       m_dStartRadian;        //单元根据半径展开后相对于x正轴得到的弧度
    int          m_nStartRadSlice;      //单元根据半径展开后相对于x正轴得到的弧度片，rad*100
    double       m_dCenRadian;          //中心轴需要运行的弧度rad，相对于x轴正方向
    int          m_nCenRadSlice;        //中心轴需要运行的弧度片，rad*100
    double       m_dEccRadian;          //偏心轴展开需要运行的弧度rad，相对于中心轴负方向
    int          m_nEccRadSlice;        //偏心轴展开需要运行的弧度片，rad*100
    double       m_dChamferDegree;      //画偏心轴外倒角圆弧的起始度数°
    int          m_nCurrentCenSlice;    //当前中心轴展开的弧度片，rad*100，相对于x轴正方向
    int          m_nCurrentEccSlice;    //当前偏心轴展开的弧度片，rad*100，相对于中心轴负方向
    int          m_nWavePos;            //轴波形位置
    int          m_nRunStyle;           //运行方式，一般运行，处理运行，结果运行
public:
    void    InitCell(NewPan *pPan, double dRadius, double dRadian);
    QRect   CalRect(double dX,double dY,double dR);
    void    Draw();
    void    DrawArc();//运行半径小于中心轴m_dCen+偏心轴m_dEcc，运行要到达的角度从x正轴开始，小于等于2*PI
    void    DrawCenEcc();//画中心轴和偏心轴
    void    DrawUnexpanded();//画未展开的中心轴和偏心轴
    void    DrawTargetPos();//画目标点
    double  LengthByPoint(const QPointF pointF);
    double  LengthByPoint(const QPointF point1,const QPointF point2);
    void    CalCurrentRadSlice();
    QPointF CalPointBySlice(int nCenSlice,int nEccSlice);//通过中心轴，偏心轴弧度片，计算光纤点
    void    CreatePoint();
    void    CreatePath();
    void    CreateArc();

public:
    inline void SetPainter(QPainter* pPainter)      {m_pPainter = pPainter;}
    inline void SetCurrentCenSlice(int nSlice)      {m_nCurrentCenSlice=nSlice;}
    inline void SetCurrentEccSlice(int nSlice)      {m_nCurrentEccSlice=nSlice;}
    inline void SetRunStyle(int nStyle)             {m_nRunStyle=nStyle;}
    inline int  GetCurrentCenSlice()                {return m_nCurrentCenSlice;}
    inline int  GetCurrentEccSlice()                {return m_nCurrentEccSlice;}
    inline int  GetCenRadSlice()                    {return m_nCenRadSlice;}
    inline int  GetEccRadSlice()                    {return m_nEccRadSlice;}
    inline double  GetRadius()                      {return m_dRadius;}
    inline double  GetCenterX()                     {return m_dCenterX;}
    inline double  GetCenterY()                     {return m_dCenterY;}
    inline bool    GetRunStatus()                   {return m_bStatus;}
    inline double  GetRunRadian()                   {return m_dRunRadian;}
    inline void SetWavePos(int nWavePos)            {m_nWavePos=nWavePos;}
    inline void SetEccRadius(double dRadius)        {m_dREcc=dRadius;}
    inline QPainterPath GetPath()                   {return m_path;}

signals:

public slots:
};

#endif // NEWCELL_H
